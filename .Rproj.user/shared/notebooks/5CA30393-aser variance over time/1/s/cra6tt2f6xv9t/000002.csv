"0","```r
state_lags <- states %>%
  group_by(State) %>%
  mutate(read_lag1 = lag(std3_reading, order_by = year),
         read_lag2 = lag(std3_reading, n= 2, order_by = year),
         read_lag3 = lag(std3_reading, n =3, order_by = year),
         read_lag4 = lag(std3_reading, n =4, order_by = year),
         read_lag5 = lag(std3_reading, n =5, order_by = year)) %>%
  ungroup()

rho = c()
# for each of the lags, calculate the correlation between current and the lag and store in vector rho
for (lag in seq(1,5)) {
  rho <- c(rho, cor(state_lags$std3_reading, state_lags[[paste(\"read_lag\",as.character(lag),sep=\"\")]], use = \"pairwise.complete.obs\"))
}
# Calculate variance of the transitory component by comparing rho_1 with the decay of rho after that
var_state_levels_persistent2 <- rho[1]/mean(rho/lag(rho), na.rm = TRUE)*var_state_levels

# Calculate the share of variance coming from other transitory sources.
# We will need this to calculate the variance breakup for changes
var_state_levels_other2 <- var_state_levels - var_state_levels_persistent2 - var_state_sampling

# Save a graph showing the decay of the correlation
quick_df <- tibble(lag = seq(0,5), correlation = c(1,rho))
ggplot(quick_df, aes(x= lag, y = correlation)) + 
  geom_line() +
  geom_point() +
  ylim(0,1)

ggsave(paste(subject, \"- correlation_decay.png\"), width = 5, height = 6 , path = output)
```"
